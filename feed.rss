<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>$&gt;swift build blog&#95;</title><description>Блог про iOS разработку и не только</description><link>https://powersl1d3.github.io</link><language>ru</language><lastBuildDate>Tue, 18 Jun 2024 15:29:23 +1000</lastBuildDate><pubDate>Tue, 18 Jun 2024 15:29:23 +1000</pubDate><ttl>250</ttl><atom:link href="https://powersl1d3.github.io/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://powersl1d3.github.io/articles/meet-async-await</guid><title>WWDC21. Meet async-await</title><description>Краткое содержание доклада Apple Meet async-await.</description><link>https://powersl1d3.github.io/articles/meet-async-await</link><pubDate>Fri, 14 Jun 2024 00:00:00 +1000</pubDate><content:encoded><![CDATA[<h1>WWDC21. Meet async-await</h1><h2>Асинхронные функции с использованием completionHandler-ов</h2><p>В начале презентации обсуждается асинхронное программирование и его использование.</p><p>Приводится пример с функцией <code>fetchThumbnail</code>. Эта функция преобразует строку (содержащую ссылку на картинку) в изображение-миниатюру. Эта функция состоит из 4 шагов:</p><img src="https://powersl1d3.github.io/images/meet-async-await/fetching-a-thumbnail.png" alt="Fetching a thumbnail"/><p>Какие то из этих шагов выполняются быстро (<code>thumbnailURLRequest</code>, <code>UIImage(data:)</code>), а какие-то медленно (<code>dataTask(with:completion:)</code>, <code>prepareThumbnail(of:completionHandler)</code>).</p><p>Сама функция на <code>completionHandler</code>-ах выглядит следующим образом:</p><pre><code><span class="keyword">func</span> fetchThumbnail(for id: <span class="type">String</span>, completion: <span class="keyword">@escaping</span> (<span class="type">UIImage</span>?, <span class="type">Error</span>?) -&gt; <span class="type">Void</span>) {
    <span class="keyword">let</span> request = <span class="call">thumbnailURLRequest</span>(for: id)
    <span class="keyword">let</span> task = <span class="type">URLSession</span>.<span class="property">shared</span>.<span class="call">dataTask</span>(with: request) { data, response, error <span class="keyword">in
        if let</span> error = error {
            <span class="call">completion</span>(<span class="keyword">nil</span>, error)
        } <span class="keyword">else if</span> (response <span class="keyword">as</span>? <span class="type">HTTPURLResponse</span>)?.<span class="property">statusCode</span> != <span class="number">200</span> {
            <span class="call">completion</span>(<span class="keyword">nil</span>, <span class="type">FetchError</span>.<span class="property">badID</span>)
        } <span class="keyword">else</span> {
            <span class="keyword">guard let</span> image = <span class="type">UIImage</span>(data: data!) <span class="keyword">else</span> {
                <span class="call">completion</span>(<span class="keyword">nil</span>, <span class="type">FetchError</span>.<span class="property">badImage</span>)
                <span class="keyword">return</span>
            }
            image.<span class="call">prepareThumbnail</span>(of: <span class="type">CGSize</span>(width: <span class="number">40</span>, height: <span class="number">40</span>)) { thumbnail <span class="keyword">in
                guard let</span> thumbnail = thumbnail <span class="keyword">else</span> {
                    <span class="call">completion</span>(<span class="keyword">nil</span>, <span class="type">FetchError</span>.<span class="property">badImage</span>)
                    <span class="keyword">return</span>
                }
                <span class="call">completion</span>(thumbnail, <span class="keyword">nil</span>)
            }
        }
    }
    task.<span class="call">resume</span>()
}
</code></pre><p>Можно заметить, что функция выглядит довольно громоздко и есть много мест, где можно ошибиться и забыть вызвать <code>completionHandler</code> в случае обработки ошибок, при этом компилятор Swift нам ничего об этом не подскажет.</p><p>Можно переписать функцию выше с использованием типа <code>Result</code>:</p><pre><code><span class="keyword">func</span> fetchThumbnail(for id: <span class="type">String</span>, completion: <span class="keyword">@escaping</span> (<span class="type">Result</span>&lt;<span class="type">UIImage</span>, <span class="type">Error</span>&gt;) -&gt; <span class="type">Void</span>) {
    <span class="keyword">let</span> request = <span class="call">thumbnailURLRequest</span>(for: id)
    <span class="keyword">let</span> task = <span class="type">URLSession</span>.<span class="property">shared</span>.<span class="call">dataTask</span>(with: request) { data, response, error <span class="keyword">in
        if let</span> error = error {
            <span class="call">completion</span>(.<span class="call">failure</span>(error))
        } <span class="keyword">else if</span> (response <span class="keyword">as</span>? <span class="type">HTTPURLResponse</span>)?.<span class="property">statusCode</span> != <span class="number">200</span> {
            <span class="call">completion</span>(.<span class="call">failure</span>(<span class="type">FetchError</span>.<span class="property">badID</span>))
        } <span class="keyword">else</span> {
            <span class="keyword">guard let</span> image = <span class="type">UIImage</span>(data: data!) <span class="keyword">else</span> {
                <span class="call">completion</span>(.<span class="call">failure</span>(<span class="type">FetchError</span>.<span class="property">badImage</span>))
                <span class="keyword">return</span>
            }
            image.<span class="call">prepareThumbnail</span>(of: <span class="type">CGSize</span>(width: <span class="number">40</span>, height: <span class="number">40</span>)) { thumbnail <span class="keyword">in
                guard let</span> thumbnail = thumbnail <span class="keyword">else</span> {
                    <span class="call">completion</span>(.<span class="call">failure</span>(<span class="type">FetchError</span>.<span class="property">badImage</span>))
                    <span class="keyword">return</span>
                }
                <span class="call">completion</span>(.<span class="call">success</span>(thumbnail))
            }
        }
    }
    task.<span class="call">resume</span>()
}
</code></pre><p>Однако это не сильно улучшает ситуацию.</p><h2>Асинхронные функции с использованием async/await</h2><p>Давайте попробуем взглянуть на ту же функцию но с использованием ключевых слов <code>async/await</code>:</p><pre><code><span class="keyword">func</span> fetchThumbnail(for id: <span class="type">String</span>) <span class="keyword">async throws</span> -&gt; <span class="type">UIImage</span> {
    <span class="keyword">let</span> request = <span class="call">thumbnailURLRequest</span>(for: id)  
    <span class="keyword">let</span> (data, response) = <span class="keyword">try await</span> <span class="type">URLSession</span>.<span class="property">shared</span>.<span class="call">data</span>(for: request)
    <span class="keyword">guard</span> (response <span class="keyword">as</span>? <span class="type">HTTPURLResponse</span>)?.<span class="property">statusCode</span> == <span class="number">200</span> <span class="keyword">else</span> { <span class="keyword">throw</span> <span class="type">FetchError</span>.<span class="property">badID</span> }
    <span class="keyword">let</span> maybeImage = <span class="type">UIImage</span>(data: data)
    <span class="keyword">guard let</span> thumbnail = <span class="keyword">await</span> maybeImage?.<span class="property">thumbnail</span> <span class="keyword">else</span> { <span class="keyword">throw</span> <span class="type">FetchError</span>.<span class="property">badImage</span> }
    <span class="keyword">return</span> thumbnail
}
</code></pre><p>Асинхронными могут быть не только функции, но и <code>property</code>, а также инициализаторы:</p><pre><code><span class="keyword">extension</span> <span class="type">UIImage</span> {
    <span class="keyword">var</span> thumbnail: <span class="type">UIImage</span>? {
        <span class="keyword">get async</span> {
            <span class="keyword">let</span> size = <span class="type">CGSize</span>(width: <span class="number">40</span>, height: <span class="number">40</span>)
            <span class="keyword">return await self</span>.<span class="call">byPreparingThumbnail</span>(ofSize: size)
        }
    }
}
</code></pre><p>Стоит отметить, что только <code>read-only</code> свойства могут быть асинхронными (также начиная с Swift 5.5 <code>property getters</code> могут быть <code>throws</code>).</p><h2>Вызов асинхронного метода внутри</h2><p>Обычный вызов синхронной функции выглядит следующим образом:</p><img src="https://powersl1d3.github.io/images/meet-async-await/normal-function-call.png" alt="A normal function call"/><p>Вызов асинхронной функции выглядит следующим образом:</p><img src="https://powersl1d3.github.io/images/meet-async-await/asynchronous-function-call.png" alt="An asynchronous function call"/><p>Асинхронный метод/функция, встречая ключевое слово <code>await</code>, приостанавливает своё выполнение, отдавая контроль над потоком системе. Система может выполнить на этом потоке другую полезную работу, а когда посчитает нужным - продолжить выполнение метода. Стоит отметить, что вызов ключевого слова <code>await</code> <em>не обязательно</em> вызывает приостановку работы метода, также как и функция, помеченная ключевым словом <code>async</code> <em>не обязана</em> содержать в себе ключевых слов <code>await</code>.</p><p>Из вышесказанного следует, что выполнение метода/функции при использовании <code>async/await</code> не является единой транзакцией.</p><img src="https://powersl1d3.github.io/images/meet-async-await/function-is-not-transaction.png" alt="The function is not a single transaction"/><p>В местах, помеченными <code>await</code>, состояние функции может измениться кардинальным способом и не нужно делать предположений сделанных относительно предыдущих(функция может приостановить своё выполнение и другие сущности могут изменить своё состояние), которые были до ключевых слов <code>await</code>. Более того, функци может продолжить своё выполнение на совершенно другом потоке.</p><h2>Несколько важных фактов про async/await</h2><ul><li>Когда мы помечаем функцию асинхронной (Помечена <code>async</code>), то мы даём ей возможность приостановить своё выполнение. Когда функция приостанавливает своё выполнение - она приостанавливает выполнение вызывавшей её функции. Поэтому вызывающая функция в таком случае тоже должна быть асинхронной (Помечена <code>async</code>).</li><li>Ключевое слово <code>await</code> обозначает где функция <em>может</em> приостановить своё выполнение (а может и тут же продолжить, каких то гарантий нет). Во время приостановки работы функции может происходить любая другая полезная работа на этом же потоке, который выполнял текущую функцию. Единожды закончившийся ожидаемый вызов функции при помощи <code>await</code> продолжает выполнение после этого ключевого слова.</li></ul><h2>Адаптирование async/await</h2><h3>Тестирование асинхронного кода</h3><p>XCTest поддерживает тестирование асинхронного кода прямо из коробки.</p><p>Пример тестирования кода написанного асинхронным способом с использованием <code>closure</code> и <code>XCTestExpectation</code>:</p><img src="https://powersl1d3.github.io/images/meet-async-await/async-closure-testing.png" alt="Testing asynchronous functions using closure"/><p>Пример тестирования кода написанного асинхронным способом с использованием <code>async/await</code>:</p><img src="https://powersl1d3.github.io/images/meet-async-await/async-testing.png" alt="Testing asynchronous functions"/><h3>Переход от синхронного кода к асинхронному</h3><p>Как было упомянуто в секции с фактами об <code>async/await</code>: асинхронная функция может приостанавливать своё выполнение, значит вызывающая её функция тоже должна быть асинхронной. Но как тогда быть? Как из синхронного контекста вызвать асинхронный?</p><img src="https://powersl1d3.github.io/images/meet-async-await/async-in-sync-context.png" alt="Using async in sync context"/><p>В этом случае нам на помощь приходят структуры <code>Task</code>. <code>Task</code>-и оборачивают вызываемую работу в замыкании и отправляют в систему для немедленного выполнения на следующем свободном потоке (подобно асинхронной функции на <code>DispatchQueue.global()</code>).</p><img src="https://powersl1d3.github.io/images/meet-async-await/async-in-task.png" alt="Using async in task"/><p>Стоит отметить, что начиная со Swift 5 SDK содержат асинхронные альтернативные методы помимо методов основанных на <code>completionHandler</code>-ах.</p><h3>Асинхронные альтернативные методы и <code>continuation</code>-ы</h3><p>Предположим, что у нас в приложении имеется имеется следующий метод:</p><img src="https://powersl1d3.github.io/images/meet-async-await/core-data-function.png" alt="Core data function"/><p>В нём мы пытаемся асинхронно получить из базы данных записи.</p><p>Давайте попробуем адаптировать и создать метод с асинхронным интерфейсом на основе метода с <code>completionHandler</code>-ами:</p><img src="https://powersl1d3.github.io/images/meet-async-await/core-data-function-adopting-async-interface.png" alt="Core data function adopting async interface"/><p>Однако, на моменте вызова метода с интерфейсом на <code>completionHandler</code>-ах, мы приходим к интересной проблеме. Вызывая метод <code>getPersistentPosts</code> мы передаем управление этой функции, которая почти тут же закончит свое выполнение и мы не сможем вернуть из метода результат вычислений, поскольку он будет известен только на моменте вызова <code>completionHandler</code>-а. То есть нам нужно обозначить момент времени, когда функция должна приостановить своё выполнение и продолжить его только тогда, когда своё выполнение закончит <code>completionHandeler</code>.</p><p>Взгляните на схему, она вам ничего не напоминает? Будто в ней не хватает одной небольшой детали. До этого мы рассматривали как система обрабатывает вызов асинхронной функции и продолжает её выполнение для нас:</p><img src="https://powersl1d3.github.io/images/meet-async-await/asynchronous-function-call.png" alt="An asynchronous function call"/><p>Давайте немного углубимся в то, как работает этот процесс засыпания и продолжения работы метода, а затем перенесём этот опыт на нашу проблему.</p><p>Когда мы вызываем асинхронную версию <code>getPersistantPosts</code>, она передаёт своё управление <code>Core Data</code>.</p><img src="https://powersl1d3.github.io/images/meet-async-await/core-data-function-diagram.png" alt="Core data function diagram"/><p>Которая в свою очередь, после выполнения запроса вызовет <code>completionHandler</code> с результатом выполнения и передаст выполнения назад в <code>getPersistantPosts</code>.</p><img src="https://powersl1d3.github.io/images/meet-async-await/core-data-function-second-diagram.png" alt="Core data function second diagram"/><p>Всё чего нам не хватает это перехода между ожиданием выполнения <code>completionHalder</code>-а и возобновления выполнения после завершения работы <code>fetchRequest</code>-а из <code>Core Data</code>.</p><p>Эта закономерность возникает постоянно и имя ей - <code>Continution</code>.</p><p>Давайте перепишем нашу функцию с использованием такого перехода:</p><img src="https://powersl1d3.github.io/images/meet-async-await/core-data-function-continuation.png" alt="Core data function continuation"/><h3>Особенности использование Continutation</h3><ul><li>Вызов блока кода помещённого в <code>Continutaion</code> является синхронным.</li><li>Вызов <code>resume</code> внутри <code>Continution</code> в любом из путей выполнения должен происходить единожды! Иначе может происходить краш приложения.</li><li>Отсутствие вызова <code>resume</code> в каком то из случаев не приводит к таким печальным последствиям, но тоже является ошибкой и означает что вызванная работа внутри <code>Continutaion</code> никогда не будет завершена. Swift runtime предупредит нас об этом.</li></ul><h3>Использование Continutaion для делегатов</h3><p>Альтернативным способом уведомить вызывающую сторону о том, что был выполнен какой то асинхронный код является использование делегатов.</p><img src="https://powersl1d3.github.io/images/meet-async-await/adopting-delegates.png" alt="Adopting delegates"/><p>Для того, чтобы адаптировать этот случай, можно сохранять <code>Continutaion</code> в локальную переменную и делать <code>resume</code> из методов делегата, когда это потребуется (Помимо этого следует проставлять <code>nil</code> в <code>Continuation</code>, чтобы случайно не вызывать его повторно).</p><img src="https://powersl1d3.github.io/images/meet-async-await/using-continuation-for-adopting-delegates.png" alt="Using continuation for adopting delegates"/>]]></content:encoded></item></channel></rss>