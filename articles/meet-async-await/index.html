<!DOCTYPE html><html lang="ru"><head><meta charset="UTF-8"/><meta property="og:site_name" content="$>swift build blog&#95;"/><link rel="canonical" href="https://powersl1d3.github.io/articles/meet-async-await"/><meta name="twitter:url" content="https://powersl1d3.github.io/articles/meet-async-await"/><meta property="og:url" content="https://powersl1d3.github.io/articles/meet-async-await"/><title>WWDC21. Meet async-await. | $&gt;swift build blog&#95;</title><meta name="twitter:title" content="WWDC21. Meet async-await. | $>swift build blog&#95;"/><meta property="og:title" content="WWDC21. Meet async-await. | $>swift build blog&#95;"/><meta name="description" content="Краткое содержание доклада Apple Meet async-await."/><meta name="twitter:description" content="Краткое содержание доклада Apple Meet async-await."/><meta property="og:description" content="Краткое содержание доклада Apple Meet async-await."/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to $>swift build blog&#95;"/></head><body class="item-page"><header><div class="wrapper"><a href="/" class="site-name">$&gt;swift build blog&#95;</a><nav><ul><li><a href="/articles" class="selected">Последние статьи</a></li><li><a href="/about">Обо мне</a></li></ul></nav></div></header><div class="wrapper"><article><div class="content"><h1>WWDC21. Meet async-await.</h1><h2>Асинхронные функции с использованием completionHandler-ов</h2><p>В начале презентации обсуждается асинхронное программирование и его использование.</p><p>Приводится пример с функцией <code>fetchThumbnail</code>. Эта функция преобразует строку (содержащую ссылку на картинку) в изображение-миниатюру. Эта функция состоит из 4 шагов:</p><img src="/images/meet-async-await/fetching-a-thumbnail.png" alt="Fetching a thumbnail.png"/><p>Какие то из этих шагов выполняются быстро (<code>thumbnailURLRequest</code>, <code>UIImage(data:)</code>), а какие-то медленно (<code>dataTask(with:completion:)</code>, <code>prepareThumbnail(of:completionHandler)</code>).</p><p>Сама функция на <code>completionHandler</code>-ах выглядит следующим образом:</p><pre><code><span class="keyword">func</span> fetchThumbnail(for id: <span class="type">String</span>, completion: <span class="keyword">@escaping</span> (<span class="type">UIImage</span>?, <span class="type">Error</span>?) -&gt; <span class="type">Void</span>) {
    <span class="keyword">let</span> request = <span class="call">thumbnailURLRequest</span>(for: id)
    <span class="keyword">let</span> task = <span class="type">URLSession</span>.<span class="property">shared</span>.<span class="call">dataTask</span>(with: request) { data, response, error <span class="keyword">in
        if let</span> error = error {
            <span class="call">completion</span>(<span class="keyword">nil</span>, error)
        } <span class="keyword">else if</span> (response <span class="keyword">as</span>? <span class="type">HTTPURLResponse</span>)?.<span class="property">statusCode</span> != <span class="number">200</span> {
            <span class="call">completion</span>(<span class="keyword">nil</span>, <span class="type">FetchError</span>.<span class="property">badID</span>)
        } <span class="keyword">else</span> {
            <span class="keyword">guard let</span> image = <span class="type">UIImage</span>(data: data!) <span class="keyword">else</span> {
                <span class="call">completion</span>(<span class="keyword">nil</span>, <span class="type">FetchError</span>.<span class="property">badImage</span>)
                <span class="keyword">return</span>
            }
            image.<span class="call">prepareThumbnail</span>(of: <span class="type">CGSize</span>(width: <span class="number">40</span>, height: <span class="number">40</span>)) { thumbnail <span class="keyword">in
                guard let</span> thumbnail = thumbnail <span class="keyword">else</span> {
                    <span class="call">completion</span>(<span class="keyword">nil</span>, <span class="type">FetchError</span>.<span class="property">badImage</span>)
                    <span class="keyword">return</span>
                }
                <span class="call">completion</span>(thumbnail, <span class="keyword">nil</span>)
            }
        }
    }
    task.<span class="call">resume</span>()
}
</code></pre><p>Можно заметить, что функция выглядит довольно громоздко и есть много мест, где можно ошибиться и забыть вызвать <code>completionHandler</code> в случае обработки ошибок, при этом компилятор Swift нам ничего об этом не подскажет.</p><p>Можно переписать функцию выше с использованием типа <code>Result</code>:</p><pre><code><span class="keyword">func</span> fetchThumbnail(for id: <span class="type">String</span>, completion: <span class="keyword">@escaping</span> (<span class="type">Result</span>&lt;<span class="type">UIImage</span>, <span class="type">Error</span>&gt;) -&gt; <span class="type">Void</span>) {
    <span class="keyword">let</span> request = <span class="call">thumbnailURLRequest</span>(for: id)
    <span class="keyword">let</span> task = <span class="type">URLSession</span>.<span class="property">shared</span>.<span class="call">dataTask</span>(with: request) { data, response, error <span class="keyword">in
        if let</span> error = error {
            <span class="call">completion</span>(.<span class="call">failure</span>(error))
        } <span class="keyword">else if</span> (response <span class="keyword">as</span>? <span class="type">HTTPURLResponse</span>)?.<span class="property">statusCode</span> != <span class="number">200</span> {
            <span class="call">completion</span>(.<span class="call">failure</span>(<span class="type">FetchError</span>.<span class="property">badID</span>))
        } <span class="keyword">else</span> {
            <span class="keyword">guard let</span> image = <span class="type">UIImage</span>(data: data!) <span class="keyword">else</span> {
                <span class="call">completion</span>(.<span class="call">failure</span>(<span class="type">FetchError</span>.<span class="property">badImage</span>))
                <span class="keyword">return</span>
            }
            image.<span class="call">prepareThumbnail</span>(of: <span class="type">CGSize</span>(width: <span class="number">40</span>, height: <span class="number">40</span>)) { thumbnail <span class="keyword">in
                guard let</span> thumbnail = thumbnail <span class="keyword">else</span> {
                    <span class="call">completion</span>(.<span class="call">failure</span>(<span class="type">FetchError</span>.<span class="property">badImage</span>))
                    <span class="keyword">return</span>
                }
                <span class="call">completion</span>(.<span class="call">success</span>(thumbnail))
            }
        }
    }
    task.<span class="call">resume</span>()
}
</code></pre><p>Однако это не сильно улучшает ситуацию.</p><h2>Асинхронные функции с использованием async/await</h2><p>Давайте попробуем взглянуть на ту же функцию но с использованием ключевых слов <code>async/await</code>:</p><pre><code><span class="keyword">func</span> fetchThumbnail(for id: <span class="type">String</span>) <span class="keyword">async throws</span> -&gt; <span class="type">UIImage</span> {
    <span class="keyword">let</span> request = <span class="call">thumbnailURLRequest</span>(for: id)  
    <span class="keyword">let</span> (data, response) = <span class="keyword">try await</span> <span class="type">URLSession</span>.<span class="property">shared</span>.<span class="call">data</span>(for: request)
    <span class="keyword">guard</span> (response <span class="keyword">as</span>? <span class="type">HTTPURLResponse</span>)?.<span class="property">statusCode</span> == <span class="number">200</span> <span class="keyword">else</span> { <span class="keyword">throw</span> <span class="type">FetchError</span>.<span class="property">badID</span> }
    <span class="keyword">let</span> maybeImage = <span class="type">UIImage</span>(data: data)
    <span class="keyword">guard let</span> thumbnail = <span class="keyword">await</span> maybeImage?.<span class="property">thumbnail</span> <span class="keyword">else</span> { <span class="keyword">throw</span> <span class="type">FetchError</span>.<span class="property">badImage</span> }
    <span class="keyword">return</span> thumbnail
}
</code></pre><p>Асинхронными могут быть не только функции, но и <code>property</code>, а также инициализаторы:</p><pre><code><span class="keyword">extension</span> <span class="type">UIImage</span> {
    <span class="keyword">var</span> thumbnail: <span class="type">UIImage</span>? {
        <span class="keyword">get async</span> {
            <span class="keyword">let</span> size = <span class="type">CGSize</span>(width: <span class="number">40</span>, height: <span class="number">40</span>)
            <span class="keyword">return await self</span>.<span class="call">byPreparingThumbnail</span>(ofSize: size)
        }
    }
}
</code></pre><p>Стоит отметить, что только <code>read-only</code> свойства могут быть асинхронными (также начиная с Swift 5.5 <code>property getters</code> могут быть <code>throws</code>).</p><h2>Вызов асинхронного метода внутри</h2><p>Обычный вызов синхронной функции выглядит следующим образом:</p><p>![[Снимок экрана 2024-06-04 в 11.37.56.png]]</p><p>Вызов асинхронной функции выглядит следующим образом:</p><p>![[Снимок экрана 2024-06-04 в 11.39.49.png]]</p><p>Асинхронный метод/функция, встречая ключевое слово <code>await</code>, приостанавливает своё выполнение, отдавая контроль над потоком системе. Система может выполнить на этом потоке другую полезную работу, а когда посчитает нужным - продолжить выполнение метода. Стоит отметить, что вызов ключевого слова <code>await</code> <em>не обязательно</em> вызывает приостановку работы метода, также как и функция, помеченная ключевым словом <code>async</code> <em>не обязана</em> содержать в себе ключевых слов <code>await</code>.</p><p>Из вышесказанного следует, что выполнение метода/функции при использовании <code>async/await</code> не является единой транзакцией.</p><p>![[Снимок экрана 2024-06-13 в 13.38.51.png]]</p><p>В местах, помеченными <code>await</code>, состояние функции может измениться кардинальным способом и не нужно делать предположений сделанных относительно предыдущих(функция может приостановить своё выполнение и другие сущности могут изменить своё состояние), которые были до ключевых слов <code>await</code>. Более того, функци может продолжить своё выполнение на совершенно другом потоке.</p><h2>Несколько важных фактов про async/await</h2><ul><li>Когда мы помечаем функцию асинхронной (Помечена <code>async</code>), то мы даём ей возможность приостановить своё выполнение. Когда функция приостанавливает своё выполнение - она приостанавливает выполнение вызывавшей её функции. Поэтому вызывающая функция в таком случае тоже должна быть асинхронной (Помечена <code>async</code>).</li><li>Ключевое слово <code>await</code> обозначает где функция <em>может</em> приостановить своё выполнение (а может и тут же продолжить, каких то гарантий нет). Во время приостановки работы функции может происходить любая другая полезная работа на этом же потоке, который выполнял текущую функцию. Единожды закончившийся ожидаемый вызов функции при помощи <code>await</code> продолжает выполнение после этого ключевого слова.</li></ul><h2>Адаптирование async/await</h2><h3>Тестирование асинхронного кода</h3><p>XCTest поддерживает тестирование асинхронного кода прямо из коробки.</p><p>Пример тестирования кода написанного асинхронным способом с использованием <code>closure</code> и <code>XCTestExpectation</code>:</p><p>![[Снимок экрана 2024-06-13 в 22.15.17.png]]</p><p>Пример тестирования кода написанного асинхронным способом с использованием <code>async/await</code>:</p><p>![[Снимок экрана 2024-06-13 в 22.17.03.png]]</p><h3>Переход от синхронного кода к асинхронному</h3><p>Как было упомянуто в секции с фактами об <code>async/await</code>: асинхронная функция может приостанавливать своё выполнение, значит вызывающая её функция тоже должна быть асинхронной. Но как тогда быть? Как из синхронного контекста вызвать асинхронный?</p><p>![[Снимок экрана 2024-06-14 в 11.02.09.png]]</p><p>В этом случае нам на помощь приходят структуры <code>Task</code>. <code>Task</code>-и оборачивают вызываемую работу в замыкании и отправляют в систему для немедленного выполнения на следующем свободном потоке (подобно асинхронной функции на <code>DispatchQueue.global()</code>).</p><p>![[Снимок экрана 2024-06-14 в 10.59.13.png]]</p><p>Стоит отметить, что начиная со Swift 5 SDK содержат асинхронные альтернативные методы помимо методов основанных на <code>completionHandler</code>-ах.</p><h3>Асинхронные альтернативные методы и <code>continuation</code>-ы</h3><p>Предположим, что у нас в приложении имеется имеется следующий метод:</p><p>![[Снимок экрана 2024-06-14 в 11.51.05.png]]</p><p>В нём мы пытаемся асинхронно получить из базы данных записи.</p><p>Давайте попробуем адаптировать и создать метод с асинхронным интерфейсом на основе метода с <code>completionHandler</code>-ами:</p><p>![[Снимок экрана 2024-06-14 в 12.01.36.png]]</p><p>Однако, на моменте вызова метода с интерфейсом на <code>completionHandler</code>-ах, мы приходим к интересной проблеме. Вызывая метод <code>getPersistentPosts</code> мы передаем управление этой функции, которая почти тут же закончит свое выполнение и мы не сможем вернуть из метода результат вычислений, поскольку он будет известен только на моменте вызова <code>completionHandler</code>-а. То есть нам нужно обозначить момент времени, когда функция должна приостановить своё выполнение и продолжить его только тогда, когда своё выполнение закончит <code>completionHandeler</code>.</p><p>Взгляните на схему, она вам ничего не напоминает? Будто в ней не хватает одной небольшой детали. До этого мы рассматривали как система обрабатывает вызов асинхронной функции и продолжает её выполнение для нас:</p><p>![[Снимок экрана 2024-06-04 в 11.39.49.png]]</p><p>Давайте немного углубимся в то, как работает этот процесс засыпания и продолжения работы метода, а затем перенесём этот опыт на нашу проблему.</p><p>Когда мы вызываем асинхронную версию <code>getPersistantPosts</code>, она передаёт своё управление <code>Core Data</code>.</p><p>![[Снимок экрана 2024-06-14 в 12.11.26.png]]</p><p>Которая в свою очередь, после выполнения запроса вызовет <code>completionHandler</code> с результатом выполнения и передаст выполнения назад в <code>getPersistantPosts</code>.</p><p>![[Снимок экрана 2024-06-14 в 12.13.34.png]]</p><p>Всё чего нам не хватает это перехода между ожиданием выполнения <code>completionHalder</code>-а и возобновления выполнения после завершения работы <code>fetchRequest</code>-а из <code>Core Data</code>.</p><p>Эта закономерность возникает постоянно и имя ей - <code>Continution</code>.</p><p>Давайте перепишем нашу функцию с использованием такого перехода:</p><p>![[Снимок экрана 2024-06-14 в 12.19.13.png]]</p><h3>Особенности использование Continutation</h3><ul><li>Вызов блока кода помещённого в <code>Continutaion</code> является синхронным.</li><li>Вызов <code>resume</code> внутри <code>Continution</code> в любом из путей выполнения должен происходить единожды! Иначе может происходить краш приложения.</li><li>Отсутствие вызова <code>resume</code> в каком то из случаев не приводит к таким печальным последствиям, но тоже является ошибкой и означает что вызванная работа внутри <code>Continutaion</code> никогда не будет завершена. Swift runtime предупредит нас об этом.</li></ul><h3>Использование Continutaion для делегатов</h3><p>Альтернативным способом уведомить вызывающую сторону о том, что был выполнен какой то асинхронный код является использование делегатов.</p><p>![[Снимок экрана 2024-06-14 в 12.33.55.png]]</p><p>Для того, чтобы адаптировать этот случай, можно сохранять <code>Continutaion</code> в локальную переменную и делать <code>resume</code> из методов делегата, когда это потребуется (Помимо этого следует проставлять <code>nil</code> в <code>Continuation</code>, чтобы случайно не вызывать его повторно).</p><p>![[Снимок экрана 2024-06-14 в 12.36.49.png]]</p></div><span>Теги: </span><ul class="tag-list"><li><a href="/tags/wwdc">WWDC</a></li><li><a href="/tags/swift">Swift</a></li><li><a href="/tags/asyncawait">Async/Await</a></li></ul></article></div><footer><p>Сгенерировано при помощи <a href="https://github.com/johnsundell/publish">Publish</a></p><p><a href="/feed.rss">RSS feed</a></p></footer></body></html>